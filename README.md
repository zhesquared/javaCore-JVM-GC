# Домашнее задание к занятию 4.1 (модуль 3): JVM. Организация памяти, сборщики мусора, VisualVM
___
## Задание 1: Понимание JVM

1. С помощью classloader'ов информация о классе ```JvmComprehension``` загружается в область памяти Metaspace.
Эта информация включает в себя имя класса, его методы и метаданные. Загрузка класса осуществляется 
посредством загрузчиков - в начале Application ClassLoader делегирует загрузку Platform ClassLoader, 
который в свою очередь передает эту задачу Bootstrap ClassLoader, после чего каждый из загрузчиков 
ищет нужный класс и загружает его. В данном случае за загрузку будет отвечать Application ClassLoader.
2. После происходит валидация кода и связывание ссылок на другие классы.
3. Далее происходит вызов метода ```main```, в результате чего в стеке создается фрейм:
   + Во фрейме метода ```main``` создается переменная ```i``` со значением 1;
   + В куче (heap) создается новый объект ```о```, которой;
   + В стеке, во фрейме метода ```main``` создается переменная ```о```, которой присваивается ссылка на ```Oblect```;
   + В этом же фрейме создается переменная ```ii```, которой присваивается значение 2;
   + В стеке создается новый фрейм метода ```printAll```;
   + Во фрейме метода ```printAll``` создается переменная ```о```, которой присваивается ссылка на ```о```, который находится в куче, ```i``` со значением 1 и ```ii``` со значением 2;
   + Во фрейме метода ```printAll``` создается переменная ```uselessVar``` со значением 700;
   + В стеке создается фрейм метода ```toString```, производятся вычисления, после чего в куче создается объект ```String```. Фрейм ```toString``` удаляется из стека. Далее создается фрейм метода ```println```, в котором создается переменная, после чего ей присваивается ссылка на объект ```String``` в куче;
   + Из стека удаляются фреймы ```println```, ```printAll```. Создается новый фрейм ```println```, создается новый объект ```String``` в куче, создается переменная в фрейме, которой присваивается ссылка на объект ```String``` в куче;

4. Во время выполнения программы в результате выполнения алгоритма запускается сборщик мусора (garbage collector), который будет делать обход по объектам в куче и удалять те, что более не достижимы, не имеют сильных ссылок и не используются.
___
## Задание 2: Исследование JVM через VisualVM

- #### Вывод консоли:
![Вывод консоли](/src/console.PNG)

+ ##### Классы:
![VisualVM Классы](/src/classes.PNG)
![VisualVM Metaspace](/src/metaspace.PNG)
1. Программа загружает 529 классов, это отображается на графике Classes. На графике Metaspace видно, что объем памяти увеличен для загрузки новых классов.
2. Программа загружает 2117 классов, на графике Classes отображено увеличение загруженных классов и увеличение объема памяти на графике Metaspace.
3. Третьим этапом программа загружает ещё 869 классов, это мы видим на графике Classes, количество загруженных классов увеличилось. Также мы видим на графике Metaspace, что размер памяти увеличен на необходимую величину для того, чтобы вместить вновь загруженные классы.

+ ##### Heap:
![VisualVM Heap](/src/heap.PNG)

- После загрузки необхлдимых классов и перед созданием объектов мы наблюдаем работу garbage collector, который очищает память кучи и снижает ее максимальный размер.
4. Программа создает 5млн объектов, на графике видно увеличение используемой памяти в куче, а также увеличение максимального объема кучи.
5. Программа создает 5млн объектов, на графике мы видим увеличение используемой памяти в куче, а также увеличение максимального объема кучи.
6. Программа создает 5млн объектов, на графике мы видим увеличение используемого места в куче, а также увеличение максимального объема кучи.

